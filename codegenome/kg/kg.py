##
## This code is part of the Code Genome Framework.
##
## (C) Copyright IBM 2023.
##
## This code is licensed under the Apache License, Version 2.0. You may
## obtain a copy of this license in the LICENSE.txt file in the root directory
## of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
##
## Any modifications or derivative works of this code must retain this
## copyright notice, and modified files need to carry a notice indicating
## that they have been altered from the originals.
##
"""
`BinGene` is class for handling genome analysis of a single binary.

`GenomeKG` is a class for handling genome analysis of multiple binaries. It provides a functionality
of an in-memory Genome KG database until we shift to a real database backend. It contains all the 
`raw_gene`s, `gene_id`s, and `bin_id`s and mapping datastructures.

`bin_id`    = binary id. Currently using sha256 of the entire binary.
`gene_id`   = gene id. Currently each `gene_id` corresponds to a function. `gene_id` is 
            currently generated using sha256 of the llvm bitcode data of a canonicalized IR 
            representation of the function.
`raw_gene`  = values of the raw gene. Currently a feature vector generated by Sigmal from the
                llvm bitcode data of a canonicalized IR representation of the function.

 ---------
|         | --sha256--> bin_id
|         |
|         |      -------------
| binnary |     |    Canon    | --Sigmal--> raw_gene1
|         | --> | IR of Func1 | --sha256--> gene_id1
|         |      -------------
|         |      -------------
|         |     |    Canon    | --Sigmal--> raw_gene2
|         | --> | IR of Func2 | --sha256--> gene_id2
|         |      -------------
 ---------

"""

import collections
import getpass
import hashlib
import logging
import os
import pickle
import re
import sys
import tempfile
import time

import numpy as np
from scipy.spatial import distance
from sklearn.neighbors import BallTree

from .._defaults import *
from .._file_format import *
from ..genes.utils import encode_gene, gene_similarity_by_ver
from ..lifters.retdec import CGRetdec
from ..pipelines import get_pipeline_by_version

DB_GENE_DIR = "genes"
DB_AUX_DIR = ".auxs"
DB_LOG_DIR = ".logs"
DB_INDEX_NAME = "index.gkg"
NODE_IDKEY = "id"


logger = logging.getLogger("codegenome.kg")

RE_FUNC = re.compile(r"; function: ([_\w\d]+?) at (0x[0-9A-Fa-f]+) -- (0x[0-9A-Fa-f]+)")
RE_FUNC_LINE = re.compile(r"(0x[0-9A-Fa-f]+):\s+([0-9A-Fa-f ]+)\s+(.+)")


def get_func_asm(fn):
    cur_func_meta = None
    cur_func = []
    func_matched = False
    for l in open(fn):
        l = l.strip()
        if not func_matched:
            m = RE_FUNC.match(l)
            if m:
                name, start_addr, end_addr = m.groups()
                cur_func_meta = {
                    "name": name,
                    "start_addr": start_addr,
                    "end_addr": end_addr,
                }
                func_matched = True
            continue
        else:
            m = RE_FUNC_LINE.match(l)
            if m:
                addr, mcode, asm = m.groups()
                cur_func.append(
                    [addr, mcode.strip(), asm.strip()]
                )  # {'addr': addr, 'mcode': mcode.strip(), 'asm': asm.strip()})
            else:
                func_matched = False
                out_func = cur_func
                out_func_meta = cur_func_meta
                cur_func = []
                # check if it's a function line
                m = RE_FUNC.match(l)
                if m:
                    name, start_addr, end_addr = m.groups()
                    cur_func_meta = {
                        "name": name,
                        "start_addr": start_addr,
                        "end_addr": end_addr,
                    }
                    func_matched = True

                yield {"metadata": out_func_meta, "asms": out_func}


class BinGene:
    def __init__(self, binid, source, canon_file=None, distance_metric="minkowski"):
        """
        params:
            source: can be GenomeKG instance or a .gene file path
        """
        self.binid = binid
        self._genes = None  # dict of raw_genes keyed by gene_ids
        self.gene_id_2_func = None  # list of gene_ids
        self.bcs = None  # IR bitcodes keyed by gene_ids
        self._gene_ids = None  # cache of list of gene_ids
        self.gene_tree = None  # raw_gene search tree
        self._gkg = None
        self.bin_meta = None
        self.distance_metric = distance_metric

        if isinstance(source, GenomeKG):
            self._gkg = source
            self.gene_id_2_func = source.bins[binid]
            self._genes = source.genes

        elif type(source) == str and os.path.exists(source):
            self._gene_file = source
            self.gene_id_2_func = {}
            self._genes = {}

            genes = read_gene_file(source)
            self.binid = genes["binid"]
            self.bin_meta = genes["file_meta"]

            for hs, func, fsg, meta in genes["genes"]:
                self.gene_id_2_func[hs] = func
                self._genes[hs] = (fsg, meta)
        else:
            raise Exception(
                "source: can only be GenomeKG instance or a .gene file path"
            )

        self._canon_file = canon_file

        self.func_2_gene = {}
        for k, v in self.gene_id_2_func.items():
            for fn in v:
                self.func_2_gene[fn] = k

    @property
    def gene_ids(self):
        if self._gene_ids is None:
            self._gene_ids = list(self.gene_id_2_func.keys())
        return self._gene_ids

    def _get_canon_file_path(self):
        if self._gkg is not None:
            meta = self._gkg.bin_metas[self.binid]
            for m in meta:
                cpath = os.path.join(
                    self._gkg._aux_dir, os.path.basename(m["file_path"]) + ".canon"
                )
                if os.path.exists(cpath):
                    return cpath
                # other option
                cpath = os.path.join(
                    os.path.dirname(m["file_path"]),
                    "sigmal",
                    os.path.basename(m["file_path"]) + ".canon",
                )
                if os.path.exists(cpath):
                    return cpath

            cpath = os.path.join(
                self._gkg._aux_dir, str(self.binid).strip().lower() + ".canon"
            )
            if os.path.exists(cpath):
                return cpath

        if self._gene_file is not None:
            fn, ext = os.path.splitext(os.path.basename(self._gene_file))
            cpath = os.path.join(os.path.dirname(self._gene_file), fn + ".canon")
            if os.path.exists(cpath):
                return cpath

        return None

    def _init_canon(self):
        if self._canon_file is None:
            self._canon_file = self._get_canon_file_path()

        self.bcs = {}
        canon = read_canon_file(self._canon_file)
        assert canon["binid"] == self.binid

        for gid, _k, _bc, meta in canon["funcs"]:
            gid = gid.lower()
            self.bcs[gid] = _bc

    def get_func_name(self, gid):
        # get function name by gene_id
        if gid in self.gene_id_2_func:
            return self.gene_id_2_func[gid]
        return None

    def get_gene_id(self, func):
        if func in self.func_2_gene:
            return self.func_2_gene[func]
        else:
            return None

    def get_gene(self, x):
        # get raw gene by gene_id or function name
        if x in self._genes:
            hs = x
        elif x in self.func_2_gene:
            hs = self.func_2_gene[x]
        else:
            raise Exception("%s is not gene_id or function name." % (x))

        return self._genes[hs][0]

    def get_gene_size(self, hs):
        if hs in self._genes:
            return self._genes[hs][1]
        else:
            return None

    def get_bc(self, x):
        # get IR bitcode by gene_id or function name
        if self.bcs is None:
            self._init_canon()
        if self.bcs is not None:
            if x in self.bcs:
                return self.bcs[x]
            elif x in self.func_2_gene:
                return self.bcs[self.func_2_gene[x]]
            else:
                raise Exception("%s is not gene_id or function name." % (x))

    def get_ll(self, x):
        # lazy loading
        import llvmlite.binding as llvm

        # get human readable IR by gene_id or function name
        return str(llvm.parse_bitcode(self.get_bc(x)))

    def __repr__(self):
        return "BinGene(binid=%s, gene_count=%d, function_count=%d)" % (
            self.binid,
            len(self._genes),
            len(self.func_2_gene),
        )

    def __str__(self):
        return self.__repr__()

    def diff(self, b):
        if self.gene_tree is None:
            self.compute_tree()

        g_b = np.vstack([b.get_gene(x) for x in b.gene_ids])

        t = time.time()
        dist, indx = self.gene_tree.query(g_b)
        t = time.time() - t
        # self.logger.debug('All query time: %f'%(t))

        out = []

        for i, d in enumerate(dist):
            ai = indx[i][0]
            ha = self.gene_ids[ai]
            hb = b.gene_ids[i]
            has = self.get_gene_size(ha)
            hbs = b.get_gene_size(hb)
            r = [d[0], ha, has, hb, hbs]
            out.append(r)
        return out

    def compute_tree(self, metric=None):
        if metric is None:
            metric = self.distance_metric
        # self.logger.debug('Calculating Gene tree of size: %d'%(len(self.gene_ids)))
        t = time.time()
        all_g = np.vstack([self.get_gene(x) for x in self.gene_ids])
        t = time.time() - t
        # self.logger.debug('Matrix creation done in %f secs'%t)

        t = time.time()
        if metric == "cosine":
            metric = "pyfunc"
            args = {"metric": metric, "func": distance.cosine}
        else:
            args = {"metric": metric}

        self.gene_tree = BallTree(all_g, **args)
        t = time.time() - t
        # self.logger.debug('Gene tree creation done in %f secs'%t)

    def query_gene(self, gene, k=1):
        return self.query_genes(np.array([gene]), k)[0]

    def query_genes(self, genes, k=1):
        if self.gene_tree is None:
            self.compute_tree()

        if type(genes) == list:
            genes = np.array(genes)

        t = time.time()

        dist, indx = self.gene_tree.query(genes, k=k)
        t = time.time() - t
        # self.logger.debug('Query time: %f secs'%(t))

        out = []
        for i, v in enumerate(dist):
            to = []
            # by k
            for j, vv in enumerate(v):
                to.append([vv, self.gene_ids[indx[i][j]]])
            out.append(to)
        return out

    def array_to_img(self, data, col_size=32, return_array=False):
        dsize = len(data)
        rows = int(dsize / col_size)
        rem = dsize % col_size
        # print((dsize, col_size, rem))
        if rem != 0:
            a = np.append(data, np.zeros(col_size - rem, dtype="B")).reshape(
                (rows + 1, col_size)
            )
        else:
            a = data.reshape((rows, col_size))

        if return_array:
            return a

        im = Image.fromarray(a)
        return im

    def show_gene(self, gn, title="", lims=(0.0, 0.4)):
        import matplotlib.pylab as plt

        vmin, vmax = lims
        plt.imshow(self.array_to_img(gn), "viridis", vmin=vmin, vmax=vmax)
        plt.colorbar()
        plt.title(title)

    def dump_ll(self, g1, outd):
        assert type(g1) == str
        # lazy loading
        import llvmlite.binding as llvm

        f1 = os.path.join(outd, "%s.ll" % (g1))
        with open(f1, "w") as f:
            f.write(str(llvm.parse_bitcode(self.get_bc(g1))))


class GenomeKG:
    def __init__(
        self,
        db_dir=None,
        gene_version=DEFAULT_GENE_VERSION,
        distance_metric="minkowski",
        aux_file_search_paths=[],
    ):
        self.distance_metric = distance_metric
        self._idkey = NODE_IDKEY
        default_dbdir = os.path.join(
            os.path.expanduser(os.environ.get("CG_CACHE_DIR", "~/.cg/cache")),
            "local.kg",
        )
        self._dbdir = os.path.abspath(db_dir if db_dir else default_dbdir)

        if not os.path.exists(self._dbdir):
            os.makedirs(self._dbdir)

        self.gene_version = gene_version
        self._pipeline = get_pipeline_by_version(gene_version)

        self.bins = {}  # mapping of bin_id to corresponding gene_ids and func names.
        # keys: bin_ids, values: dict{ gene_ids: list of func_names }
        self.genes = collections.OrderedDict()  # dict of raw_genes keyed by gene_ids
        self._gene_ids = None  # gene_id cache
        self.gene_2_bin = {}  # mapping from gene_id to bin_id
        self.gene_tree = None  # raw_gene search tree
        self.bin_metas = {}  # binary metadata
        self.aux_file_search_paths = aux_file_search_paths

        self.re_h = re.compile("[a-z0-9]{64}")
        self.logger = logger

        self._index_fn = os.path.join(self._dbdir, DB_INDEX_NAME)
        self._gene_dir = os.path.join(self._dbdir, DB_GENE_DIR, gene_version)
        self._aux_dir = os.path.join(self._dbdir, DB_AUX_DIR)
        self._log_dir = os.path.join(self._dbdir, DB_LOG_DIR)

        self._init()

    def _init(self):
        for x in [self._dbdir, self._gene_dir, self._aux_dir, self._log_dir]:
            if not os.path.exists(x):
                os.makedirs(x)

    @property
    def gene_ids(self):
        if self._gene_ids is None:
            self._gene_ids = list(self.genes.keys())
        return self._gene_ids

    def get_gene_ids(self, func, bin_id=False, include_bin_id=False):
        # TODO create a func_2_gene map
        out = set()
        if bin_id:
            v = self.bins.get(bin_id, {})
            for gid, v2 in v.items():
                if func in v2:
                    if include_bin_id:
                        out.add((gid, bin_id))
                    else:
                        out.add(gid)

        else:
            for bid, v in self.bins.items():
                for gid, v2 in v.items():
                    if func in v2:
                        if include_bin_id:
                            out.add((gid, bid))
                        else:
                            out.add(gid)
        return list(out)

    def get_bin_id(self, gid):
        if gid in self.gene_2_bin:
            return self.gene_2_bin[gid]

    def serialize(self):
        return [
            self._dbdir,
            self.bins,
            self.genes,
            self.gene_2_bin,
            self.gene_tree,
            self.bin_metas,
        ]

    def deserialize(self, sdata):
        (
            self._dbdir,
            self.bins,
            self.genes,
            self.gene_2_bin,
            self.gene_tree,
            self.bin_metas,
        ) = sdata

    def _get_index_file(self):
        return

    def load_index(self, inf=None):
        if inf is None:
            inf = self._index_fn
        if os.path.exists(inf):
            data = read_gkg_file(inf)
            self.deserialize(data["data"])

    def save_index(self, outf=None):
        assert os.path.isdir(self._dbdir)
        if outf is None:
            outf = self._index_fn
        data = prep_gkg_file(self)

        joblib.dump(data, outf, compress=False, protocol=pickle.HIGHEST_PROTOCOL)
        return outf

    def get_gene(self, gene_id):
        # get raw gene by gene_id
        if gene_id in self.genes:
            return self.genes[gene_id][0]
        else:
            return None

    def get_gene_info(
        self,
        gene_id,
        bin_id=None,
        function_name=None,
        llvm_ir=True,
        include_asm=False,
        gene_value=True,
        func_names=True,
    ):
        # get gene info
        out = self.get_node(gene_id)
        if out:
            if out.get("type") == "gene":
                if llvm_ir:
                    try:
                        ir = self.get_ll(gene_id)
                        if ir:
                            out["llvm_ir"] = ir
                        else:
                            self.logger.warning(f"IR not found for {gene_id}")
                    except Exception as ex:
                        self.logger.error(f"Exception: {ex}")
                if include_asm:
                    try:
                        asm = self.get_asm(gene_id, bin_id, func_name=function_name)
                        if asm:
                            out["asm"] = asm
                        else:
                            self.logger.warning(f"ASM not found for {gene_id}")
                    except Exception as ex:
                        self.logger.error(f"Exception: {ex}")

                if gene_value:
                    out["value"] = encode_gene(out["value"])
                else:
                    out.pop("value")

                if func_names:
                    out["function_names"] = self.gene_to_bin_func(gene_id)
            else:
                out = None
        return out

    def get_gene_size(self, gene_id):
        if gene_id in self.genes:
            return self.genes[gene_id][1]
        else:
            return None

    def get_gene_maps(self, gene_id, limit=10):
        # get gene maps (all the bin_ids along with all genes associated with them) by gene_id
        gene_id = gene_id.strip().lower()
        out = {}
        if gene_id in self.gene_2_bin:
            for binid in self.gene_2_bin[gene_id][:limit]:
                out[binid] = self.bins[gene_id]
        return out

    def _get_aux_file_path(self, binid, aux_ext):
        cfn = str(binid).strip().lower() + aux_ext

        for search_path in self.aux_file_search_paths + [self._aux_dir]:
            path = os.path.join(search_path, cfn)
            if os.path.exists(path):
                return path
            else:
                meta = self.bin_metas[binid]
                for m in meta:
                    cpath = os.path.join(
                        search_path, os.path.basename(m["file_path"]) + aux_ext
                    )
                    if os.path.exists(cpath):
                        return cpath
                    # other option
                    cpath = os.path.join(
                        os.path.dirname(m["file_path"]),
                        "sigmal",
                        os.path.basename(m["file_path"]) + aux_ext,
                    )
                    if os.path.exists(cpath):
                        return cpath

    def _get_canon_file_path(self, binid):
        return self._get_aux_file_path(binid, ".canon")

    def _get_asm_file_path(self, binid):
        return self._get_aux_file_path(binid, ".dsm")

    def get_bc(self, gene_id):
        gene_id = gene_id.strip().lower()
        if gene_id in self.gene_2_bin:
            binid = self.gene_2_bin[gene_id][0]
            cpath = self._get_canon_file_path(binid)
            if cpath:
                with open(cpath, "rb") as f:
                    canon = pickle.load(f)
                    for _gid, _k, _bc, _meta in canon["funcs"]:
                        if _gid.lower() == gene_id:
                            return _bc
        return None

    def get_ll(self, x):
        import llvmlite.binding as llvm
        xbc = self.get_bc(x)
        if xbc is not None:
            return str(llvm.parse_bitcode(xbc))
        return None

    def get_asm(self, gene_id, bin_id=None, func_name=None):
        gene_id = gene_id.strip().lower()
        if bin_id is None:
            if gene_id in self.gene_2_bin:
                bin_id = self.gene_2_bin[gene_id][0]
        if bin_id:
            bingene = self.get_bin(bin_id)
            if func_name is None or func_name == "":
                func_names = bingene.get_func_name(gene_id)
                if func_names:
                    func_name = func_names[-1]
            cpath = self._get_asm_file_path(bin_id)
            if cpath and func_name:
                for fobj in get_func_asm(cpath):
                    if func_name == fobj.get("metadata").get("name"):
                        return fobj

        return None

    def get_bin(self, binid):
        return BinGene(binid, source=self)

    def _upsort(self, binid, gid, funcs, raw_gene, sz):
        if binid in self.bins:
            bn = self.bins[binid]
        else:
            bn = self.bins[binid] = {}

        if gid in bn:
            fns = bn[gid]
        else:
            fns = bn[gid] = []

        for func in funcs:
            if func not in fns:
                fns.append(func)

        # update genes
        if gid not in self.genes:
            self.genes[gid] = (raw_gene, sz)

        # update cache
        self._gene_ids = list(self.genes.keys())

        # update reverse map
        if gid in self.gene_2_bin:
            bns = self.gene_2_bin[gid]
        else:
            bns = self.gene_2_bin[gid] = []

        if binid not in bns:
            bns.append(binid)
        return True

    def delete_file(self, file_id):
        status = True

        node = self.get_node(file_id)
        if node:
            file_fn = node.get("metadata.name", "")
            if os.path.exists(file_fn):
                try:
                    os.remove(file_fn)
                except Exception as ex:
                    logger.error(f"Error removing file {file_fn}")
        else:
            status = False

        # try clearing anyways
        gene_fn = self._get_gene_file_path(file_id)
        if os.path.exists(gene_fn):
            try:
                os.remove(gene_fn)
            except Exception as ex:
                logger.error(f"Error removing file {file_fn}")

        # clear aux files
        for fn in os.listdir(self._aux_dir):
            if fn.startswith(file_id):
                try:
                    os.remove(os.path.join(self._aux_dir, fn))
                except:
                    pass

        if file_id in self.bin_metas:
            self.bin_metas.pop(file_id)
        if file_id in self.bins:
            self.bins.pop(file_id)

        return status

    def add_file(self, file_path, overwrite=False, keep_aux_files=True):
        # TODO move to pipeline
        if not os.path.exists(file_path):
            self.logger.error(f"File does not exist. {file_path}.")
            return False

        with open(file_path, "rb") as f:
            bin_id = hashlib.sha256(f.read()).hexdigest()

        dst = os.path.join(self._gene_dir, bin_id + ".gene")

        if os.path.exists(dst):
            if not overwrite:
                self.logger.warning(f"Genes already processed.")
                genes = read_gene_file(dst)
                self._add_bin_genes(genes)
                return bin_id

        genes = self._pipeline.process_file(
            file_path,
            output_dir=self._aux_dir,
            output_fname=bin_id,
            keep_aux_files=keep_aux_files,
            overwrite=True,
            logger=self.logger,
            return_genes=True,
            keep_gene_file=True,
        )
        if genes:
            src = os.path.join(self._aux_dir, bin_id + ".gene")
            os.rename(src, dst)
            self._add_bin_genes(genes)
            return bin_id
        else:
            return None

    def _add_bin_genes(self, genes):
        binid = genes["binid"]
        bmeta = self.bin_metas.setdefault(binid, [])
        bmeta.append(genes["file_meta"])
        for hs, func, fsg, gn_meta in genes["genes"]:
            self._upsort(binid, hs, func, fsg, gn_meta)

    def _get_gene_file_path(self, bin_id):
        return os.path.join(self._gene_dir, bin_id + ".gene")

    def _load_bin_genes(self, bin_id):
        fn = self._get_gene_file_path(bin_id)
        if os.path.exists(fn):
            self.logger.debug("Reading: " + fn)
            genes = read_gene_file(fn)
            self._add_bin_genes(genes)
            return True
        return False

    def load(self, update=True):
        if os.path.exists(self._index_fn):
            if not update:
                self.load_index()
                return True

        dbdir = self._gene_dir
        for fn in os.listdir(dbdir):
            ext = fn.strip().lower().split(".")[-1]
            if ext == "gene":
                try:
                    fn = os.path.join(dbdir, fn)
                    self.logger.debug("Reading: " + fn)
                    genes = read_gene_file(fn)
                    binid = genes["binid"]

                    if binid in self.bin_metas:
                        bmeta = self.bin_metas[binid]
                    else:
                        bmeta = self.bin_metas[binid] = []
                    bmeta.append(genes["file_meta"])

                    for hs, func, fsg, gn_meta in genes["genes"]:
                        self._upsort(binid, hs, func, fsg, gn_meta)

                except Exception as e:
                    print(e)
                    self.logger.error("ERR:" + str(e))
                    return False
        return True

    def compute_tree(self, metric=None):
        if metric is None:
            metric = self.distance_metric
        self.logger.debug(
            "Calculating Gene tree of size: %d, metric: %s" % (len(self.genes), metric)
        )
        t = time.time()
        all_g = np.vstack([x[0] for x in self.genes.values()])
        t = time.time() - t
        self.logger.debug("Matrix creation done in %f secs" % t)

        t = time.time()
        if metric == "cosine":
            metric = "pyfunc"
            args = {"metric": metric, "func": distance.cosine}
        else:
            args = {"metric": metric}

        self.gene_tree = BallTree(all_g, **args)

        t = time.time() - t
        self.logger.debug("Gene tree creation done in %f secs" % t)

    def _get_last_updated(self, node_id):
        ts = int(time.time())
        fn = None
        if node_id in self.bins:
            fn = self._get_gene_file_path(node_id)

        if fn:
            if os.path.exists(fn):
                ts = int(os.path.getmtime(fn))
        return ts

    def get_node(self, node_id, on_demand_load=True):
        n = None
        if node_id in self.bins:
            md = self.bin_metas.get(node_id, [{}])[0]  # use the first metadata
            n = {
                self._idkey: node_id,
                "sha256": node_id,
                "type": "file",
                "metadata.filesize": md.get("file_size"),
                "metadata.name": md.get("file_path"),
                "gene_count." + self.gene_version: len(self.bins.get(node_id, {})),
                "last_updated": int(self._get_last_updated(node_id)),
            }
        elif node_id in self.genes:
            raw_gene, md = self.genes[node_id]
            canon_bc_size, file_offset = md

            n = {
                self._idkey: node_id,
                "type": "gene",
                "subtype": "func_gene",
                "version": self.gene_version,
                "value": raw_gene,
                "canon_bc_size": canon_bc_size,
                "file_offset": file_offset,
            }
        else:
            if on_demand_load:
                if self._load_bin_genes(node_id):
                    return self.get_node(node_id, on_demand_load=False)
        return n

    def get_file2genes(
        self, _id, version, limit=0, return_edges=False, min_gene_size=0
    ):
        assert self.gene_version == version
        ret = []
        genes = self.bins.get(_id, {})
        edges = []

        for gid, funcs in genes.items():
            gene = self.get_node(gid)
            if min_gene_size > 0:
                size = gene.get("canon_bc_size")
                if size and size < min_gene_size:
                    # skip
                    continue

            edges.append(
                {
                    "from": _id,
                    "to": gid,
                    "type": "GENE",
                    "version": self.gene_version,
                    "func_names": funcs,
                }
            )
            ret.append(gene)

        if return_edges:
            return ret, edges
        else:
            return ret

    def files_compare_by_shared_genes(
        self,
        node1,
        node2,
        gene_version=DEFAULT_EXEC_GENE_VERSION,
        match_sim_thr=FILE_COMPARE_FUNC_MATCH_SIM_THRESHOLD,
        mismatch_sim_thr=FILE_COMPARE_FUNC_MISMATCH_SIM_THRESHOLD,
        method=DEFAULT_CALCULATION_METHOD,
        output_detail=VALID_OUTPUT_DETAILS[0],
        min_size=0,
    ):
        """
        Returns (results, stats) dicts tuple.
        """

        self.logger.debug(
            f"files_compare_by_shared_genes({str(node1)[:80]},{str(node1)[:80]},{gene_version}, {method}, {output_detail}) called."
        )

        if method not in KNOWN_CALCULATION_METHODS:
            raise Exception(
                f"Unknown method: {method}. Allowed methods: {KNOWN_CALCULATION_METHODS}"
            )

        gc_key = "gene_count." + gene_version

        # node can be node_id or node dict object
        t1 = time.time()

        def map_node(node):
            if type(node) == dict:
                fnode = node
                node_id = fnode[self._idkey]
            else:
                node_id = node
                fnode = self.get_node(node_id)
            return node_id, fnode

        node_id1, fnode1 = map_node(node1)
        node_id2, fnode2 = map_node(node2)

        if fnode1 is None:
            return {"error": f"File not found for file id {node_id1}"}, {}
        if fnode2 is None:
            return {"error": f"File not found for file id {node_id2}"}, {}

        for fnode in [fnode1, fnode2]:
            if fnode.get(gc_key, 0) == 0:
                return {
                    "error": f"Not an executable file or no function level gene found for the file '{fnode['metadata.name']}'. NodeID: '{fnode['id']}'"
                }, {}

        genes1 = self.get_file2genes(
            node_id1,
            gene_version,
            limit=MAX_GENES_PER_FILE_COMPARE,
            return_edges=True,
            min_gene_size=MIN_GENE_SIZE_FILE_COMPARE,
        )
        genes2 = self.get_file2genes(
            node_id2,
            gene_version,
            limit=MAX_GENES_PER_FILE_COMPARE,
            return_edges=True,
            min_gene_size=MIN_GENE_SIZE_FILE_COMPARE,
        )

        t2 = time.time()

        g1dict, e1dict = {x["id"]: x for x in genes1[0]}, {
            x["to"]: x for x in genes1[1]
        }
        g2dict, e2dict = {x["id"]: x for x in genes2[0]}, {
            x["to"]: x for x in genes2[1]
        }

        def get_func_dict(edges, fdict):
            for x in edges:
                gid = x["to"]
                for func in x.get("func_names", []):
                    fdict[func] = gid
            return fdict

        f1dict = get_func_dict(genes1[1], {})
        f2dict = get_func_dict(genes2[1], {})

        match = set(g1dict).intersection(set(g2dict))
        g1extra = list(set(g1dict) - match)
        g2extra = list(set(g2dict) - match)
        out = []

        self.logger.info(
            f"g1count: {len(g1dict)}, g2count: {len(g2dict)}, match: {len(match)}"
        )

        # g2extra_genes = {g2dict[x]['id']]:decode_gene_by_ver(g2dict[x] for x in g2extra}
        xmatch = []
        xdel = []
        xadd = []
        xmismatch = []
        for g1id in g1extra:
            best_match_id = None
            best_match_sim = 0.0

            # try function name heuristics first
            f1s = e1dict.get(g1id).get("func_names", [])
            func_match = None
            for f1 in f1s:
                g2id = f2dict.get(f1)
                if g2id:
                    best_match_id = g2id
                    best_match_sim = gene_similarity_by_ver(
                        g1dict[g1id], g2dict[g2id], adjusted=False, normalized=True
                    )
                    if best_match_sim >= match_sim_thr:
                        xmatch.append([g1id, best_match_id, best_match_sim])
                        if best_match_id in g2extra:
                            g2extra.remove(
                                best_match_id
                            )  # remove it so it does not match for next
                        func_match = True
                        break
                    func_match = False

            if func_match is not None:
                # do not consider address based func name for negative match
                if not f1.startswith("function_"):
                    if func_match == False:
                        if (
                            best_match_sim > mismatch_sim_thr
                        ):  # if the genes are not too diff
                            xmismatch.append([g1id, g2id, best_match_sim])
                        else:
                            xdel.append([g1id, best_match_id, best_match_sim])
                            xadd.append([g2id, best_match_sim])
                        if g2id in g2extra:
                            g2extra.remove(
                                g2id
                            )  # remove it so it does not match for next
                    continue

            if best_match_sim < match_sim_thr:
                # compare all
                for g2id in g2extra:
                    sim = gene_similarity_by_ver(
                        g1dict[g1id], g2dict[g2id], adjusted=False, normalized=True
                    )
                    if best_match_sim is None:
                        best_match_sim = sim
                        best_match_id = g2id
                    elif best_match_sim < sim:
                        best_match_sim = sim
                        best_match_id = g2id

            if best_match_sim >= match_sim_thr:
                xmatch.append([g1id, best_match_id, best_match_sim])
                if best_match_id in g2extra:
                    g2extra.remove(
                        best_match_id
                    )  # remove it so it does not match for next
            else:
                xdel.append([g1id, best_match_id, best_match_sim])

        t3 = time.time()
        self.logger.info(
            f"g1count: {len(g1dict)}, g2count: {len(g2dict)}, match: {len(match)}, Xmatch: {len(xmatch)}, del: {len(xdel)}, add: {len(g2extra)}"
        )

        def append_match_rows(m1, m2, op, score):
            f1s = list(set(e1dict.get(m1, {}).get("func_names", [])))
            f2s = list(set(e2dict.get(m2, {}).get("func_names", [])))
            # can be multiple func names
            if len(f1s) == 0 or len(f2s) == 0:
                self.logger.warning(f"Can not get function names for gene {m1} or {m2}")
                return
            for f1 in f1s:
                if f1 in f2s:
                    f2 = f1
                else:
                    # func mismatch
                    f2 = f2s[0]
                row = {"op": op, "f1": f1, "f2": f2, "score": score, "g1": m1, "g2": m2}
                # if op=='~' and f1!=f2:
                #    print(f1,f2,score)
                out.append(row)

        def append_nomatch_rows(m, op, score):
            f1s = f2s = []
            if op == "-":
                f1s = list(set(e1dict.get(m, {}).get("func_names", [])))
            elif op == "+":
                f2s = list(set(e2dict.get(m, {}).get("func_names", [])))
            else:
                self.logger.error(f"OP {op} is unknonw")
                return

            # can be multiple func names
            if len(f1s) == 0 and len(f2s) == 0:
                self.logger.error(f"Can not get function names for gene {m}")
                return

            for f1 in f1s:
                row = {"op": op, "f1": f1, "f2": "", "score": score, "g1": m, "g2": ""}
                out.append(row)
            for f2 in f2s:
                row = {"op": op, "f1": "", "f2": f2, "score": score, "g1": "", "g2": m}
                out.append(row)

        for m in match:
            append_match_rows(m, m, "=", 100)

        for m1, m2, score in xmatch:
            append_match_rows(m1, m2, "~", int(score * 100))

        out.sort(key=lambda x: x["f1"])

        for m1, m2, score in xmismatch:
            append_match_rows(m1, m2, "!", int(score * 100))

        for m1, m2, score in xdel:
            append_nomatch_rows(m1, "-", int(score * 100))

        # remaining g2extra is addition
        xadd_ids = [x[0] for x in xadd]
        for x in g2extra:
            if x not in xadd_ids:
                xadd.append([x, 0.0])
        for x, score in xadd:
            append_nomatch_rows(x, "+", int(score * 100))

        lm, lxm, ld, lr = len(match), len(xmatch), len(xdel), len(g2extra)
        mcount = lm + lxm
        tot = lm + lxm + ld + lr

        metadata = {
            "match_count": mcount,
            "match_ratio": f"{mcount}/{tot}",
            "gene_counts": [len(g1dict), len(g2dict)],
        }
        if method == "jaccard_distance" or method == "all":
            dist = 1.0 - float(mcount) / tot
        elif method == "jaccard_distance_w" or method == "all":
            mgenes_size = sum([g1dict[x].get("canon_bc_size", 0) for x in match])
            mgenes_size += sum([g1dict[x[0]].get("canon_bc_size", 0) for x in xmatch])
            q_genes_size_tot = mgenes_size + sum(
                [g1dict[x[0]].get("canon_bc_size", 0) for x in xdel]
            )
            q_genes_size_tot += sum(
                [g2dict[x].get("canon_bc_size", 0) for x in g2extra]
            )

            dist = 1.0 - float(mgenes_size) / q_genes_size_tot
            metadata.update(
                {
                    "total_matched_gene_size": mgenes_size,
                    "total_query_gene_size": q_genes_size_tot,
                }
            )
        else:
            msg = "Unsupported file compare method {method}"
            self.logger.error(msg)
            raise Exception(msg)

        results = {
            "similarity": int(100 * (1.0 - dist)),
            "jaccard_distance": round(dist, 2),
            "matches": metadata,
            "diff_details": out,
        }

        t4 = time.time()

        stats = {
            "main_query_time": t2 - t1,
            "dist_compute_time": t3 - t2,
            "result_prep_time": t4 - t3,
        }

        return results, stats

    def bindiff(
        self,
        bid1,
        bid2,
        match_sim_thr=FILE_COMPARE_FUNC_MATCH_SIM_THRESHOLD,
        mismatch_sim_thr=FILE_COMPARE_FUNC_MISMATCH_SIM_THRESHOLD,
        method=DEFAULT_CALCULATION_METHOD,
        output_detail=VALID_OUTPUT_DETAILS[0],
    ):

        r, s = self.files_compare_by_shared_genes(
            bid1,
            bid2,
            gene_version=self.gene_version,
            match_sim_thr=match_sim_thr,
            mismatch_sim_thr=mismatch_sim_thr,
            method=method,
            output_detail=output_detail,
        )
        return r, s

    def bindiff_old(self, a, b, thr=0.3, metric=None):
        if metric is None:
            metric = self.distance_metric
        g_a = np.vstack([self.genes[x][0] for x in self.bins[a].keys()])
        g_b = np.vstack([self.genes[x][0] for x in self.bins[b].keys()])

        self.logger.debug(
            "Bindiff gene fcounts, %s: %d, %s: %d" % (a, len(g_a), b, len(g_b))
        )

        t = time.time()
        if metric == "cosine":
            metric = "pyfunc"
            args = {"metric": metric, "func": distance.cosine}
        else:
            args = {"metric": metric}

        g_b_t = BallTree(g_b, **args)
        t = time.time() - t
        self.logger.debug("Balltree time: %f, a: %s, b: %s" % (t, a, b))

        t = time.time()
        dist, indx = g_b_t.query(g_a)
        t = time.time() - t
        self.logger.debug("All query time: %f, a: %s, b: %s" % (t, a, b))

        sset = set()

        for i in range(len(dist)):
            if dist[i][0] <= thr:
                sset.add((i, indx[i][0]))

        tot = len(g_a) + len(g_b) - len(sset)
        sim = float(len(sset)) / float(tot)
        diff_score = 1.0 - sim

        self.logger.debug(
            "Diffs: sim: %d, total: %d, a: %s, b: %s" % (len(sset), tot, a, b)
        )
        return diff_score

    def bindiff_sigmal_v1(self, a, b):
        import sigmal

        s = sigmal.Sigmal()
        # assume files are at parrent dir
        pdir = os.path.abspath(self._dbdir + "/..")
        af = os.path.join(pdir, a)
        bf = os.path.join(pdir, b)
        if os.path.exists(af) and os.path.exists(bf):
            return s.dist(af, bf)
        else:
            return None

    def gene_compare(self, gene_path):
        binid, ext = os.path.splitext(os.path.basename(gene_path))
        b = BinGene(binid.lower(), gene_path)
        # TODO

    def query_gene(self, gene, k=1):
        return self.query_genes(np.array([gene]), k)[0]

    def query_genes(self, genes, k=1):
        if self.gene_tree is None:
            self.compute_tree()

        if type(genes) == list:
            genes = np.array(genes)

        t = time.time()

        dist, indx = self.gene_tree.query(genes, k=k)
        t = time.time() - t
        self.logger.debug("Query time: %f secs" % (t))

        out = []
        for i, v in enumerate(dist):
            to = []
            # by k
            for j, vv in enumerate(v):
                to.append([vv, self.gene_ids[indx[i][j]]])
            out.append(to)
        return out

    def dump_ll(self, g1, outd):
        import llvmlite.binding as llvm
        assert type(g1) == str
        f1 = os.path.join(outd, "%s.ll" % (g1))
        with open(f1, "w") as f:
            f.write(str(llvm.parse_bitcode(self.get_bc(g1))))

    def gene_to_bin_func(self, gid):
        out = {}
        for b in self.gene_2_bin[gid]:
            out[b] = self.bins[b][gid]  # list of function names
        return out

    def gene_diff(self, g1, g2):
        return np.linalg.norm(g1 - g2)

    def gene_info(self, gid):
        bids = self.gene_2_bin[gid]
        out = {}
        for bid in bids:
            out[bid] = {
                "paths": [x["file_path"] for x in self.bin_metas[bid]],
                "funcs": self.bins[bid][gid],
            }
        return out

    def gene_tag(self, gid, func_names=False, full_path=False):
        """
        Single tag
        """
        infos = self.gene_info(gid)
        out = []
        flist = []
        for info in infos.values():
            fns = "|".join(info["funcs"])
            flist += info["funcs"]
            for bp in info["paths"]:
                if full_path:
                    out.append(bp + "__" + fns)
                else:
                    out.append(os.path.basename(bp) + "__" + fns)

        tag = ":".join(out)
        if func_names:
            return tag, flist
        return tag

    def gene_tags(self, gid, full_path=False):
        """
        List of tags for each instance of functions
        """
        infos = self.gene_info(gid)
        out = []
        for info in infos.values():
            for bp in info["paths"]:
                for fn in info["funcs"]:
                    if full_path:
                        out.append(bp + "__" + fn)
                    else:
                        out.append(os.path.basename(bp) + "__" + fn)

        return out
